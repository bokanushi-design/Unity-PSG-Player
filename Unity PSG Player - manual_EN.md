# Unity PSG Player

This is a library for synthesis PSG (Programmable Sound Generator) sound sources such as retro game consoles on Unity. The performance data is MML (Music Macro Language) text, which describes musical notation in text, allowing easy creation of music data. The library is designed to produce expressions similar to those of NES sound generators (except DPCM).

* The sound generator can produce four types of square waves, a triangle wave, and two types of noise. The triangle wave is a 4-bit waveform.
* Performance expressions include sweep, LFO (vibrato), and volume envelope.

> I'm not aiming for a perfect recreation of the Famicom sound source. (It's too much trouble.)  
> My goal is solely to produce sounds using only Unity, without preparing separate sound clips.

The PSG Player produces monophonic (single-note) sound. To play NES 4-note polyphonic sounds (excluding DPCM), you can achieve this by preparing multiple PSG Players and playing them simultaneously.

## Quick Guide

### Basic Usage

1. Place the PSG Player prefab in the Hierarchy.  
![fig01](./img/fig01.png)

2. Prepare a PSGPlayer class variable in the script you are operating, and attach the PSG Player object you have placed.  
![fig02](./img/fig02.png)

3. The MML written in the [mmlString](#mmlstring) variable of the PSGPlayer will be played by [Play()](#play) function.  
For details on MML, refer to the [MML Reference](Unity%20PSG%20Player%20-%20MML%20reference.md).  
![fig03](./img/fig03.png)

### Multi-channel Usage

1. Place the PSG Player prefab according to the required number of channels.  
![fig04](./img/fig04.png)

2. Attach the MMLSplitter script to the appropriate game object.  
3. Assign the placed PSG Player to the [psgPlayers](#psgplayers) of the MMLSplitter from the Inspector.  
![fig05](./img/fig05.png)

4. Place the MML into the [multiChMMLString](#multichmmlstring) variable of MMLSplitter, distribute the MML to each channel using the [SplitMML()](#splitmml) function, and play it using the [PlayAllChannels()](#playallchannels) function.  
![fig06](./img/fig06.png)

## Composition

The Unity PSG Player consists of:

* The “**PSG Player**” that synthesizes sound according to sequence data
* The “**MML Decoder**” that converts MML to sequence data
* The “**MML Splitter**” that splits MML

![composition](./img/composition.png)

MML Splitter is not required for single sound use.  
An AudioSource component is also required to play the sound generated by PSG Player.  

## Summary

PSG Player synthesizes monophonic waveforms: square waves (pulse waves), triangle waves, and noise.
The generated sound is attached as an AudioClip to an AudioSource resource and streamed.
During streaming, the AudioClip sequentially requests the necessary buffer data, and PSG Player calculates the waveform data for each request.  

PSG Player sequentially processes sequence data from a List array to calculate pitch and volume.
Conversion from MML to sequence data is performed by the MML Decoder.  

Additionally, use the MML Splitter to distribute multi-channel MML.
It processes each line of the MML and determines the destination channel based on the characters at the beginning of the line.
For details, refer to the [MML Reference](Unity%20PSG%20Player%20-%20MML%20reference.md).
Besides distributing MML, the MML Splitter can also centralize control over each PSG Player.  

When playing sound effects using PSG, retro game consoles would interrupt the playback of one BGM channel to play sound effects in real time. However, the PSG Player buffers pre-loaded sounds, making it impossible to play sound effects with precise timing.  
To play sound effects in PSG Player similarly to retro game consoles, prepare a separate PSG Player instance dedicated solely to sound effects and mute one of the BGM channels.

When using PSG Player in multi-channel mode, using the AudioMixer makes it easier to adjust volume levels and other settings.  

## About Sample rate

PSG Player allows you to set the sample rate for generated AudioClips.
The sample rate is the number of samples per second.
Since processing occurs for each sample, increasing the sample rate also increases CPU load.  

Additionally, the sample rate affects the upper limit of the frequency of the generated sound.  
The number of samples required per wavelength varies depending on the tone, as follows:  

| Tone | Samples |
|:----|:----|
| Square wave | 2 samples |
| 25%(75%) Pulse wave | 4 samples |
| 12.5% Pulse wave | 8 samples |
| Triangle wave | 32 samples |

The frequency of sound that can be produced without issues is determined by dividing the sample rate by the number of samples mentioned above, ~~so the highest pitch achievable, especially for a triangle wave, will be lower~~.

`v0.9.2beta` Slightly modified the triangle wave generation logic, enabling it to produce high frequencies comparable to those of a square wave.

* This represents the upper limit for achieving the expected pitch; higher notes will cause the tone to deteriorate.  
 At the default sampling rate, proper sound reproduction is only guaranteed up to approximately the seventh octave (o7).  
* Due to unique noise processing, lower sample rates will cause volume to decrease at high frequencies.  

## Musical Expression

PSG Player allows you to use volume envelopes, sweeps, and LFOs for performance expression.  
However, noise sounds and sounds generated by frequency specification will disable sweep and LFO effects that alter pitch.  

## About Rendering

`v0.9.6beta`

PSG Player has been developed assuming the use of the Stream from AudioClip.Create().  
Stream playback distributes the load, so even long sequences like background music can be played with reasonably good responsiveness.  
However, since buffering occurs when Create() is called, there was some concern about playing timing-sensitive sound effects.  
  
Rendering outputs the entire sequence as waveform data for an AudioClip.  
By preparing this waveform data in advance, you can achieve performance equivalent to playing a standard audio file.  
However, rendering is computationally intensive, so converting long time performances may cause the program to freeze.  
  
Using asynchronous rendering allows you to return to the main thread at regular intervals, thereby distributing the load.  
Instead, the time required to complete rendering will increase.  
We recommend using **streams**, **rendering**, and **asynchronous rendering** appropriately depending on the use case.  
  
Note that during rendering, the sequence loop command (MML loop “L”) is disabled.  
(There's this mysterious Unity behavior where loop points embedded in audio files get applied to AudioClips, but there's no way to add them when creating them manually...)

By the way, in WebGL, the Stream from AudioClip.Create() is unsupported (it plays but the buffer doesn't update), but rendered AudioClips can be played.

## PSG Player script refference

### List of Variables & Public Functions

* [Variables](#variables)
  * [mmlDecoder](#mmldecoder)
  * [audioSource](#audiosource)
  * [sampleRate](#samplerate)
  * [audioClipSizeMilliSec](#audioclipsizemillisec)
  * [a4Freq](#a4freq)
  * [tickPerNote](#tickpernote)
  * [programChange](#programchange)
  * [seqListIndex](#seqlistindex)
  * [seqList](#seqlist)
  * [mmlString](#mmlstring)
  * [asyncRenderIsDone](#asyncrenderisdone)
  * [asyncRenderProgress](#asyncrenderprogress)
  * [renderedDatas](#rendereddatas)
* [Public Functions](#public-functions)
  * [Play()](#play)
  * [Play(string \_mmlString)](#playstring-_mmlstring)
  * [DecodeMML()](#decodemml)
  * [PlayDecoded()](#playdecoded)
  * [PlaySequence()](#playsequence)
  * [Stop()](#stop)
  * [IsPlaying()](#isplaying)
  * [Mute(bool isOn)](#mutebool-ison)
  * [ExportSeqJson(bool _prettyPrint)](#exportseqjsonbool-_prettyprint)
  * [DecodeAndExportSeqJson(bool _prettyPrint)](#decodeandexportseqjsonbool-_prettyprint)
  * [GetSeqJson()](#getseqjson)
  * [ImportSeqJson(string _jsonString)](#importseqjsonstring-_jsonstring)
  * [SetSeqJson(SeqJson _seqJson)](#setseqjsonseqjson-_seqjson)
  * [RenderSequenceTodClipData()](#rendersequencetodclipdata)
  * [ExportRenderedAudioClip(bool isAsyncRendered)](#exportrenderedaudioclipbool-isasyncrendered)
  * [RenderSeqToClipDataAsync(int interruptSample)](#renderseqtoclipdataasyncint-interruptsample)
  * [CalcSeqSample()](#calcseqsample)
  * [PlayRenderedClipData(bool isLoop)](#playrenderedclipdatabool-isloop)

----

### Variables

----

#### mmlDecoder

``` C# PSGPlayer.cs
[SerializeField] private MMLDecoder mmlDecoder;
```

Register the MML Decoder component that converts MML into sequence data.  

----

#### audioSource

``` C# PSGPlayer.cs
[SerializeField] private AudioSource audioSource;
```

Register the AudioSource that will receive the generated AudioClip.  

----

#### sampleRate

``` C# PSGPlayer.cs
public int sampleRate = 32000;
```

Sets the sample rate for the AudioClip.  
The default is 32000Hz (32kHz).  

----

#### audioClipSizeMilliSec

``` C# PSGPlayer.cs
public int audioClipSizeMilliSec = 1000;
```

Sets the length of the AudioClip.  
The default is 1000 milliseconds (1 second).  

----

#### a4Freq

``` C# PSGPlayer.cs
public float a4Freq = 440f;
```

Set the frequency of the A note in the fourth octave (o4a), which serves as the standard for the musical scale.  
The default is 440Hz.  
This variable can be changed using MML commands.  

----

#### tickPerNote

``` C# PSGPlayer.cs
public int tickPerNote = 960;
```

Set the resolution to one beat (quarter note).  
Note duration is converted to the number of ticks based on this resolution, and the actual note length (in seconds) is calculated from the tempo and this resolution.  

(Example: An eighth note corresponds to 480 ticks. At a tempo of 120, the note duration is  
60[sec] / 120[notePerMin] * 480[tick] / 960[tickPerNote] = 0.25[sec]  
which equals 0.25 seconds.)  

----

#### programChange

``` C# PSGPlayer.cs
public int programChange;
```

The number of the tone to be generated.  

| Number | Wave form |
|:--:|:-- |
| 0 | Pulse wave（12.5%） |
| 1 | Pulse wave（25%） |
| 2 | Square wave（50%） |
| 3 | Pulse wave（75%） |
| 4 | Triangle wave |
| 5 | Noise |
| 6 | Short-cycle noise |

This variable can be changed using MML commands.

----

#### seqListIndex

``` C# PSGPlayer.cs
[SerializeField] private int seqListIndex = 0;
```

Current position in sequence data processing.  
Mainly displayed for debugging purposes.  

----

#### seqList

``` C# PSGPlayer.cs
[SerializeField] private List<SeqEvent> seqList = new();
```

A List array of sequence data.  
Mainly displayed for debugging purposes.  

----

#### mmlString

``` C# PSGPlayer.cs
[Multiline] public string mmlString = "";
```

This is the MML string to be played.  
Pass this variable to the MML Decoder to convert it into sequence data.  

----

#### asyncRenderIsDone

``` C# PSGPlayer.cs
public bool asyncRenderIsDone { get; private set; } = false;
```

`v0.9.6beta`

Asynchronous rendering completes and returns `True`.  
Use after calling [RenderSeqToClipDataAsync()](#renderseqtoclipdataasyncint-interruptsample).

----

#### asyncRenderProgress

``` C# PSGPlayer.cs
public float asyncRenderProgress { get; private set; } = 0f;
```

`v0.9.6beta`

The progress rate for asynchronous rendering increases from 0 to 1.  
Use after calling [RenderSeqToClipDataAsync()](#renderseqtoclipdataasyncint-interruptsample).

----

#### renderedDatas

``` C# PSGPlayer.cs
public float[] renderedDatas { get; private set; }
```

`v0.9.6beta`

This contains clip data generated by [RenderSequenceToClipData()](#rendersequencetodclipdata) or [RenderSeqToClipDataAsync()](#renderseqtoclipdataasyncint-interruptsample).  

----

### Public Functions

----

#### Play()

``` C# PSGPlayer.cs
public void Play();
```

* Parameter : None  

Converts the MML string in the mmlString variable into sequence data and begins playback.  

----

#### Play(string _mmlString)

``` C# PSGPlayer.cs
public void Play(string _mmlString);
```

* Parameter : **_mmlString** MML string  

Pass the parameter arguments to the mmlString variable, convert them to sequence data, and start playback.  

----

#### DecodeMML()

``` C# PSGPlayer.cs
public bool DecodeMML();
```

* Parameter : None  
* Return value : `True` if decoding succeeds  

Pass the MML string from the mmlString variable to the MML Decoder to convert it into sequence data.  

----

#### PlayDecoded()

``` C# PSGPlayer.cs
public void PlayDecoded();
```

* Parameter : None  

Plays back decoded sequence data.  
Since no conversion processing is performed, reduced CPU load is expected.  

----

#### PlaySequence()

``` C# PSGPlayer.cs
public void PlaySequence();
```

* Parameter : None  

Plays back decoded sequence data.  
Same as [PlayDecoded()](#playdecoded).

----

#### Stop()

``` C# PSGPlayer.cs
public void Stop();
```

* Parameter : None  

Stop the currently playing audio.  

----

#### IsPlaying()

``` C# PSGPlayer.cs
public bool IsPlaying();
```

* Parameter : None
* Return value : `True` if playing

Returns the playback status of AudioSource.  

----

#### Mute(bool isOn)

``` C# PSGPlayer.cs
public void Mute(bool isOn);
```

* Parameter: **isOn** Set `True` to Mute on

When muted, the AudioSource is silenced and the generated sample is set to 0 (silence).  
When unmuted with `False`, the AudioSource is immediately unmuted, but the sample remains silent until the next note event occurs.  
However, if unmuted before the buffered sample plays out, the already generated sample will be played.  

----

#### ExportSeqJson(bool _prettyPrint)

``` C# PSGPlayer.cs
public string ExportSeqJson(bool _prettyPrint)
```

`v0.9.3beta`

* Parameter: **_prettyPrint** `True` enables line breaks and indentation (`False` by default)
* Return value: **JSON string**

The decoded MML sequence data is converted to JSON and output as a string.  
If there is no sequence data ([DecodeMML()](#decodemml) or [Play()](#play) has not been called), Null is returned.  
The JSON content combines the [tickPerNote](#tickpernote) value with the [seqList](#seqlist).

----

#### DecodeAndExportSeqJson(bool _prettyPrint)

``` C# PSGPlayer.cs
public string DecodeAndExportSeqJson(bool _prettyPrint)
```

`v0.9.3beta`

* Parameter: **_prettyPrint** `True` enables line breaks and indentation (`False` by default)
* Return value: **JSON string**

After decoding MML, serializes the sequence data into JSON and outputs it.  

----

#### GetSeqJson()

``` C# PSGPlayer.cs
public SeqJson GetSeqJson()
```

`v0.9.3beta`

* Parameter: None
* Return value: **SeqJson class object**

Outputs the decoded MML sequence data as a SeqJson class object.  
This is the data before being converted to JSON by [ExportSeqJson()](#exportseqjsonbool-_prettyprint).  
It is primarily used when exporting multi-channel JSON with the MML Splitter.

----

#### ImportSeqJson(string _jsonString)

``` C# PSGPlayer.cs
public bool ImportSeqJson(string _jsonString)
```

`v0.9.3beta`

* Parameter: **_jsonString** JSON string
* Return value: `True` if import succeeds

Import JSON-formatted strings as sequence data.  
At this time, the value of [tickPerNote](#tickpernote) is also loaded.

----

#### SetSeqJson(SeqJson _seqJson)

``` C# PSGPlayer.cs
public bool SetSeqJson(SeqJson _seqJson)
```

`v0.9.3beta`

* Parameter: **_jsonString** JSON string
* Return value: `True` if import succeeds

Directly reads the [tickPerNote](#tickpernote) value and sequence data from a SeqJson class object.  
Primarily used when importing multi-channel JSON with MML Splitter.

----

#### RenderSequenceTodClipData()

``` C# PSGPlayer.cs
public float[] RenderSequenceTodClipData()
```

`v0.9.4beta`

* Parameter: None
* Return value: **Sample data consisting of a float array**

Generates the waveform data for the entire sequence.  
Calculates each sample at the sample rate specified by [sampleRate](#samplerate), then returns each sample as a float array.  
The higher the sample rate and the longer the sequence, rendering will take longer time.  
Additionally, the sequence loop command ([MML Loop “L”](Unity%20PSG%20Player%20-%20manual_JP.md)) will be disabled during rendering.

----

#### ExportRenderedAudioClip(bool isAsyncRendered)

``` C# PSGPlayer.cs
public AudioClip ExportRenderedAudioClip(bool isAsyncRendered)
```

`v0.9.4beta`

* Parameter: None
* Return value: **Rendered AudioClip**

Generate waveform data for the entire sequence and export it as an AudioClip.  
The sample rate of the AudioClip is set to the value specified by [samplRate](#samplerate).  
When prioritizing responsiveness for sound effects, you can use this function to prepare the AudioClip in advance.  
Conversely, for long sequences such as background music, be aware to rendering will takes long time.

`v0.9.6beta`

* Parameter: **isAsyncRendered**　Use renderedDatas when `True` (default `False`)
* Return value: **Rendered AudioClip**

Export the AudioClip using [renderedDatas](#rendereddatas) without performing rendering.  

----

#### RenderSeqToClipDataAsync(int interruptSample)

``` c# PSGPlayer.cs
public bool RenderSeqToClipDataAsync(int interruptSample)
```

`v0.9.6beta`

* Parameter: **interruptSample**　Number of samples where processing is interrupted
* Return value: `True` when rendering starts successfully

Begin asynchronous rendering of the entire sequence to waveform data.  
Monitor rendering within the main thread's Update() method or similar.
The rendering progress increases from 0 to 1 using [asyncRenderProgress](#asyncrenderprogress).  
When rendering completes, [asyncRenderIsDone](#asyncrenderisdone) becomes `True`.  
The generated clip data is stored in [renderedDatas](#rendereddatas).  
[ExportRenderedAudioClip(true)](#exportrenderedaudioclipbool-isasyncrendered) converts [renderedDatas](#rendereddatas) into an AudioClip.  
Note that the sequence loop command ([MML Loop “L”](Unity%20PSG%20Player%20-%20manual_JP.md)) is disabled during rendering.

----

#### CalcSeqSample()

``` c# PSGPlayer.cs
public int CalcSeqSample()
```

`v0.9.6beta`

* Parameter: None
* Return value: Number of samples after rendering

Calculates the size of the clip data generated when rendering.

----

#### PlayRenderedClipData(bool isLoop)

``` c# PSGPlayer.cs
public bool PlayRenderedClipData(bool isLoop)
```

`v0.9.6beta`

* Parameter: **isLoop**　`True` for loop playback
* Return value: `True` if playback is successful

Use [renderedDatas](#rendereddatas) to generate an AudioClip and play it using the AudioSource specified for the PSG Player.

----

## MML Splitter script refference

### [MML Splitter] List of Variables & Public Functions

* [Variables](#mml-splitter-variables)
  * [psgPlayers](#psgplayers)
  * [multiChMMLString](#multichmmlstring)
  * [asyncMultiRenderIsDone](#asyncmultirenderisdone)
  * [asyncMultiRenderProgress](#asyncmultirenderprogress)
* [Public Functions](#mml-splitter-public-functions)
  * [SplitMML()](#splitmml)
  * [SplitMML(string \_multiChMMLString)](#splitmmlstring-_multichmmlstring)
  * [SetAllChannelsSampleRate(int \_rate)](#setallchannelssamplerateint-_rate)
  * [SetAllChannelClipSize(int \_msec)](#setallchannelclipsizeint-_msec)
  * [PlayAllChannels()](#playallchannels)
  * [PlayAllChannelsDecoded()](#playallchannelsdecoded)
  * [PlayAllChannelsSequence()](#playallchannelssequence)
  * [DecodeAllChannels()](#decodeallchannels)
  * [StopAllChannels()](#stopallchannels)
  * [IsAnyChannelPlaying()](#isanychannelplaying)
  * [MuteChannel(int channel, bool isMute)](#mutechannelint-channel-bool-ismute)
  * [ExportMultiSeqJson(bool _prettyPrint)](#exportmultiseqjsonbool-_prettyprint)
  * [DecodeAndExportMultiSeqJson(bool _prettyPrint)](#decodeandexportmultiseqjsonbool-_prettyprint)
  * [ImportMultiSeqJson(string _jsonString)](#importmultiseqjsonstring-_jsonstring)
  * [ExportMixedAudioClip(int _sampleRate, bool isAsyncRendered)](#exportmixedaudioclipint-_samplerate-bool-isasyncrendered)
  * [RenderMultiSeqToClipDataAsync(int _sampleRate, int interruptSample)](#rendermultiseqtoclipdataasyncint-_samplerate-int-interruptsample)
  * [PlayAllChannelsRenderedClipData(bool isLoop)](#playallchannelsrenderedclipdatabool-isloop)

----

### [MML Splitter] Variables

----

#### psgPlayers

``` C# MMLSplitter.cs
[SerializeField] private PSGPlayer[] psgPlayers;
```

Register a PSG Player component for each channel to send the MML in segments.  

----

#### multiChMMLString

``` C# MMLSplitter.cs
public string multiChMMLString;
```

Register the original MML string to be sent in segments.  

----

#### asyncMultiRenderIsDone

``` c# MMLSplitter.cs
public bool asyncMultiRenderIsDone { get; private set; } = false;
```

`v0.9.6beta`

Asynchronous rendering completes on all channels returns `True`.  
Use after calling [RenderMultiSeqToClipDataAsync()](#rendermultiseqtoclipdataasyncint-_samplerate-int-interruptsample).

----

#### asyncMultiRenderProgress

``` c# MMLSplitter.cs
public float asyncMultiRenderProgress { get; private set; } = 0f;
```

`v0.9.6beta`

The progress rate for asynchronous rendering across all channels increases from 0 to 1.  
Use after calling [RenderMultiSeqToClipDataAsync()](#rendermultiseqtoclipdataasyncint-_samplerate-int-interruptsample).

----

### [MML Splitter] Public Functions

----

#### SplitMML()

``` C# MMLSplitter.cs
public void SplitMML();
```

* Parameter : None

Splits the MML string from multiChMMLString and sends it to the PSG Player registered in psgPlayers.  
For channel assignment details, refer to “[MML Reference](Unity%20PSG%20Player%20-%20MML%20reference.md#Track%20Header)”.  

----

#### SplitMML(string _multiChMMLString)

``` C# MMLSplitter.cs
public void SplitMML(string _multiChMMLString);
```

* Parameter : **_multiChMMLString** Multi-channel MML string

Pass the parameter arguments to the multiChMMLString variable to send the MML to PSG Player in segments.  

----

#### SetAllChannelsSampleRate(int _rate)

``` C# MMLSplitter.cs
public void SetAllChannelsSampleRate(int _rate);
```

* Parameter : **_rate** Sample rate

Set the sample rate for all PSG players (in Hz).  

----

#### SetAllChannelClipSize(int _msec)

``` C# MMLSplitter.cs
public void SetAllChannelClipSize(int _msec);
```

* Parameter : **_msec** AudioClip length

Sets the AudioClip length for all PSG Players (in milliseconds).  

----

#### PlayAllChannels()

``` C# MMLSplitter.cs
public void PlayAllChannels();
```

* Parameter : None

All PSG Players decode MML and play simultaneously.  

----

#### PlayAllChannelsDecoded()

``` C# MMLSplitter.cs
public void PlayAllChannelsDecoded();
```

* Parameter : None

Play back the decoded sequence data simultaneously on all PSG Players.  

----

#### PlayAllChannelsSequence()

``` C# MMLSplitter.cs
public void PlayAllChannelsSequence()
```

* Parameter : None

Plays sequence data simultaneously on all PSG players.  
Same as [PlayAllChannelsDecoded()](#playallchannelsdecoded).

----

#### DecodeAllChannels()

``` C# MMLSplitter.cs
public void DecodeAllChannels()
```

* Parameter : None

All PSG Players decode MML into sequence data.  
Since multi-channel MML is not transmitted in split segments, please execute [SplitMML()](#splitmml) beforehand.

----

#### StopAllChannels()

``` C# MMLSplitter.cs
public void StopAllChannels();
```

* Parameter : None

Stop playing all PSG players.  

----

#### IsAnyChannelPlaying()

``` C# MMLSplitter.cs
public bool IsAnyChannelPlaying();
```

* Parameter : None
* Return value : `True` if any PSG Player is currently playing

Returns `True` if any of the AudioSources for each PSG Player is currently playing.  

----

#### MuteChannel(int channel, bool isMute)

``` C# MMLSplitter.cs
public void MuteChannel(int channel, bool isMute);
```

* Parameter: **channel** Target channel  
　　　　　　　**isMute** `True` for mute on

Mutes the specified channel.

----

#### ExportMultiSeqJson(bool _prettyPrint)

``` C# MMLSplitter.cs
public string ExportMultiSeqJson(bool _prettyPrint)
```

`v0.9.3beta`

* Parameter: **_prettyPrint**  Enables line breaks and indentation when set to `True` (default `False`)
* Return value: **JSON string**

The decoded MML sequence data for each PSG Player is consolidated into JSON and output as a string.  
The JSON contents consist of a list of [SeqJson class objects](#getseqjson) output by each PSG Player.

----

#### DecodeAndExportMultiSeqJson(bool _prettyPrint)

``` C# MMLSplitter.cs
public string DecodeAndExportMultiSeqJson(bool _prettyPrint)
```

`v0.9.3beta`

* Parameter: **_prettyPrint**  Enables line breaks and indentation when set to `True` (default `False`)
* Return value: **JSON string**

Each PSG Player's MML is decoded, then the sequence data is converted to JSON and output.  
Since multi-channel MML is not transmitted in split segments, please execute [SplitMML()](#splitmml) beforehand.

----

#### ImportMultiSeqJson(string _jsonString)

``` C# MMLSplitter.cs
public void ImportMultiSeqJson(string _jsonString)
```

`v0.9.3beta`

* Parametr: **_jsonString** JSON string

Import JSON-formatted strings as multi-channel sequence data.  

----

#### ExportMixedAudioClip(int _sampleRate, bool isAsyncRendered)

``` C# MMLSplitter.cs
public AudioClip ExportMixedAudioClip(int _sampleRate, bool isAsyncRendered)
```

`v0.9.4beta`

* Parameter: **_sampleRate** AudioClip sample rate
* Return value: **AudioClip**

Mix the waveform data rendered by each PSG Player and export as an AudioClip.  
The combined waveform data is summed by dividing by the number of channels to ensure it does not exceed the sample value range.  
Therefore, the maximum volume of a single tone decreases depending on the number of channels.  
Additionally, since the sample rate must be consistent across all channels, after using this function, the [sampleRate](#samplerate) of each PSG Player will be set to the value specified in the argument.  
Please note that rendering all PSG players before mixing can take a significant amount of time, especially for longer sequences.

`v0.9.6beta`

* Parameter: **_sampleRate** AudioClip sample rate
* Parameter: **isAsyncRendered**　Use rendered waveform data (default `False`)
* Return value: **AudioClip**

Setting `isAsyncRendered` to `True` will mix the [renderedDatas](#rendereddatas) from each channel and export an AudioClip.  
In this case, rendering is not performed, so after calling [RenderMultiSeqToClipDataAsync()](#rendermultiseqtoclipdataasyncint-_samplerate-int-interruptsample), use it only after [asyncMultiRenderIsDone](#asyncmultirenderisdone) returns `True`.

----

#### RenderMultiSeqToClipDataAsync(int _sampleRate, int interruptSample)

``` c# MMLSplitter.cs
public bool RenderMultiSeqToClipDataAsync(int _sampleRate, int interruptSample)
```

`v0.9.6beta`

* Parameter: **_sampleRate** AudioClip sample rate
* Parameter: **interruptSample**　Number of samples where processing is interrupted
* Return value: Once rendering begins on any channel, return `True`

Begin asynchronous rendering on all channels.  
Monitor rendering within the main thread's Update() method or similar.  
The rendering progress increases from 0 to 1 using [asyncMultiRenderProgress](#asyncmultirenderprogress).  
When rendering completes, [asyncMultiRenderIsDone](#asyncmultirenderisdone) becomes `True`.  
The generated clip data is stored in the [renderedDatas](#rendereddatas) of each PSG Player.  
You can use [ExportMixedAudioClip()](#exportmixedaudioclipint-_samplerate-bool-isasyncrendered) to mix [renderedDatas](#rendereddatas) and convert them into an AudioClip.  
Note that the sequence loop command ([MML Loop “L”](Unity%20PSG%20Player%20-%20manual_JP.md)) is disabled during rendering.

----

#### PlayAllChannelsRenderedClipData(bool isLoop)

``` c# MMLSplitter.cs
public void PlayAllChannelsRenderedClipData(bool isLoop)
```

`v0.9.6beta`

* Parameter: **isLoop**　If `True`, loop playback
* Return value: None

Use [renderedDatas](#rendereddatas) to generate AudioClips on each channel, then play them using the AudioSource specified for each PSG Player.
Since the audio is played unmixed, you can adjust the volume or mute each channel individually.

----
